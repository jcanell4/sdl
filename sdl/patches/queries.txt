//S'afegeix un nou camp per controlar s'ha fet un càlcul aproximat de la data d'edició o per contra, es tracta d'una dada fiable;
CREATE TABLE CALCDATEMAP (ID varchar(3) PRIMARY KEY, DESC varchar(20));
@MANDATORY_START;
INSERT INTO CALCDATEMAP VALUES('SCL', 'sense classificar');
INSERT INTO CALCDATEMAP VALUES('FIA', 'fiable');
INSERT INTO CALCDATEMAP VALUES('APR', 'aproximada');
INSERT INTO CALCDATEMAP VALUES('ILL', 'illegible');
@MANDATORY_END;
ALTER TABLE RESOURCE ADD CALCDATE_ID varchar(3) default 'SCL';
ALTER TABLE RESOURCE ADD FOREIGN KEY (CALCDATE_ID) REFERENCES CALCDATEMAP(ID);
ALTER TABLE SEARCHRESOURCE ADD SEARCHDATE varchar(15);
UPDATE SEARCHRESOURCE SET SEARCHRESOURCE.SEARCHDATE=(SELECT RESOURCE.SEARCHDATE from RESOURCE WHERE SEARCHRESOURCE.RESOURCEID=RESOURCE.ID) WHERE EXISTS (SELECT RESOURCE.SEARCHDATE FROM RESOURCE WHERE SEARCHRESOURCE.RESOURCEID=RESOURCE.ID);
ALTER TABLE RESOURCE DROP COLUMN SEARCHDATE;
RUN PACHCODE CLASS: org.elsquatrecaps.jig.sdl.persistence.patcher.RenameFilesForVersion2023;
ALTER TABLE RESOURCE ADD DOCID varchar(30); 
ALTER TABLE RESOURCE ADD PAGEID varchar(30); 
UPDATE RESOURCE as r SET DOCID=ID, PAGEID='';
CREATE TABLE RF_TMP AS SELECT * FROM RESOURCE_FORMAT;
DROP TABLE RESOURCE_FORMAT;
CREATE TABLE RESOURCE_FORMAT (RESOURCE_ID VARCHAR(255) NOT NULL, RESOURCEFORMATS_ORDER INTEGER NOT NULL, FORMAT varchar(5), CONSTRAINT "RF_PK" PRIMARY KEY (RESOURCE_ID, RESOURCEFORMATS_ORDER), CONSTRAINT "RF_R_FK" FOREIGN KEY (RESOURCE_ID) REFERENCES RESOURCE(ID));
MERGE INTO RESOURCE_FORMAT AS RF USING RF_TMP ON (RF.RESOURCE_ID=RF_TMP.RESOURCE_ID AND RF.RESOURCEFORMATS_ORDER=RF_TMP.SUPPORTEDFORMATS_ORDER) WHEN NOT MATCHED THEN INSERT(RESOURCE_ID, RESOURCEFORMATS_ORDER, FORMAT) VALUES(RF_TMP.RESOURCE_ID, RF_TMP.SUPPORTEDFORMATS_ORDER, RF_TMP.SUPPORTEDFORMATS);
DROP TABLE RF_TMP;
ALTER TABLE RESOURCE_FORMAT ADD CONTENTTYPE varchar(1); 
UPDATE RESOURCE_FORMAT SET CONTENTTYPE='D';
ALTER TABLE RESOURCE DROP COLUMN FILENAME;
ALTER TABLE RESOURCE ALTER COLUMN DOCID varchar(64); 
ALTER TABLE RESOURCE ALTER COLUMN PAGEID varchar(32); 
ALTER TABLE RESOURCE_FRAGMENT ALTER COLUMN FRAGMENTS varchar(500); 
ALTER TABLE RESOURCE ADD PREVIOUS_PAGE varchar(255); 
ALTER TABLE RESOURCE ADD NEXT_PAGE varchar(255);
CREATE TABLE RF_TMP AS SELECT * FROM RESOURCE_FRAGMENT;
DROP TABLE RESOURCE_FRAGMENT;
CREATE TABLE RESOURCE_FRAGMENT (SEARCHRESOURCE_REPOSITORY VARCHAR(255) NOT NULL, SEARCHRESOURCE_RESOURCEID VARCHAR(255) NOT NULL, SEARCHRESOURCE_SEARCHCRITERIA VARCHAR(255) NOT NULL, FRAGMENTS VARCHAR(500), FRAGMENTS_ORDER INTEGER NOT NULL, CONSTRAINT "RFT_PK" PRIMARY KEY (SEARCHRESOURCE_REPOSITORY, SEARCHRESOURCE_RESOURCEID, SEARCHRESOURCE_SEARCHCRITERIA, FRAGMENTS_ORDER), CONSTRAINT "RFT_SR_FK" FOREIGN KEY (SEARCHRESOURCE_REPOSITORY, SEARCHRESOURCE_RESOURCEID, SEARCHRESOURCE_SEARCHCRITERIA) REFERENCES SEARCHRESOURCE(REPOSITORY, RESOURCEID, SEARCHCRITERIA));
CREATE VIEW CP AS (SELECT RESOURCE_ID as SEARCHRESOURCE_RESOURCEID, FRAGMENTS, FRAGMENTS_ORDER, REPOSITORY as SEARCHRESOURCE_REPOSITORY, SEARCHCRITERIA as SEARCHRESOURCE_SEARCHCRITERIA FROM RF_TMP INNER JOIN SEARCHRESOURCE as SR ON (RF_TMP.RESOURCE_ID=SR.RESOURCEID));
MERGE INTO RESOURCE_FRAGMENT AS RF USING CP ON (CP.SEARCHRESOURCE_REPOSITORY=RF.SEARCHRESOURCE_REPOSITORY and CP.SEARCHRESOURCE_RESOURCEID=RF.SEARCHRESOURCE_RESOURCEID AND CP.SEARCHRESOURCE_SEARCHCRITERIA=RF.SEARCHRESOURCE_SEARCHCRITERIA and CP.FRAGMENTS_ORDER=RF.FRAGMENTS_ORDER) WHEN NOT MATCHED THEN INSERT(SEARCHRESOURCE_REPOSITORY, SEARCHRESOURCE_RESOURCEID, SEARCHRESOURCE_SEARCHCRITERIA, FRAGMENTS, FRAGMENTS_ORDER) VALUES(CP.SEARCHRESOURCE_REPOSITORY, CP.SEARCHRESOURCE_RESOURCEID, CP.SEARCHRESOURCE_SEARCHCRITERIA, CP.FRAGMENTS, CP.FRAGMENTS_ORDER);
DROP VIEW CP;
DROP TABLE RF_TMP;
RUN PACHCODE CLASS: org.elsquatrecaps.jig.sdl.persistence.patcher.RenameFilesForVersion2024;
